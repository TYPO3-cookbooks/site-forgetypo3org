<?php
/*
* Signature-Based Single Sign-On Framework
* TPA Adapter for
* Redmine ( http://www.redmine.org )
*
*  Version            : 0.2
*  Last update        : 17.04.2008 by Robert Lemke
*
  Changelog
    0.1
     initial release
    0.2
     Added the "has signed CLA" flag
    0.x
     Fixed indefined index img_hash on line 123 warning
     Fixed mt_rand requires 2 args on line 136 warning
*/

$redmineConf = array(
	'databaseHost' => '<%= node['redmine']['database']['hostname'] %>',
	'databaseName' => '<%= node['redmine']['database']['name'] %>',
	'databaseUsername' => '<%= node['redmine']['database']['username'] %>',
	'databasePassword' => '<%= node['redmine']['database']['password'] %>'
);

/**
 * Returns the supported SSO version
 *
 * @return string Supported SSO version
 */
function get_version() {
	return '2.0';
}

/**
 *  function which is called after including this file in the SSO-Agent.
 *
 *  @param
 *    User_Name    string    Username the Session will be created for
 *    remote_addr  string    Remoteaddress of the users system
 *    agent        string    Browser
 *    sso_url      string    Url where the user will be redirected after establishing a session for him
 *    sso_version  string    the protocol version of the calling agent
 *    sso_action   string    the action to perform. Right now this is either 'logon' or 'create_modify'
 *    sso_userdata string    the userdata submitted by the agent
 *
 *  @return        string    return the session data
 */
function sso($username, $ip, $agent, $sso_url, $sso_version='', $sso_action='', $sso_userdata='') {
	$sso_action = ($sso_version == '') ? 'logon' : $sso_action;

		// Convert the sso_userdata into a proper array:
	$userDataKeysAndValues = explode('|', $sso_userdata);
	foreach ($userDataKeysAndValues as $userDataKeyAndValue) {
		list($key, $value) = explode('=', $userDataKeyAndValue);
		$userData[$key] = $value;
	}

		// Take the requested action:
	switch ($sso_action) {
		case 'logon' :
			return redmineLogon($username, $userData, $sso_url);
		break;
	}
}
/**
 * Hashes a password in case it is not yet hashed
 */
function hashPassword($password) {
    if (substr($password, 0, 3) == '$P$') {
	return $password;
    } else {
	$salt = chr(rand(48, 122)).chr(rand(48, 122)).chr(rand(48, 122)).chr(rand(48, 122));
	
	// mark salt as md5 salt
	$salt = '$1$'.$salt.'$';
	return crypt($password, $salt);
    }
}
/**
 *
 */
function redmineLogon($username, $userData, $sso_url) {
	global $redmineConf;
	try {
		if (array_key_exists('password', $userData)) {
			$userData['salted_password'] = hashPassword($userData['password']);
			$userData['hashed_password'] = sha1($userData['password']); // for redmine devel site
			// hashed_password does not work anymore, but i do not care for now (--sebastian)
			unset($userData['password']);
		}
		if (!array_key_exists('tx_t3ocla_hassignedcla', $userData)) {
		    $userData['tx_t3ocla_hassignedcla'] = 0;
		}
		
		$dbh = new PDO('mysql:host='. $redmineConf['databaseHost'] . ';dbname=' . $redmineConf['databaseName'] . ';charset=utf8', $redmineConf['databaseUsername'], $redmineConf['databasePassword']);

		$foundUserRecord = FALSE;
		$statement = $dbh->prepare('SELECT id, login, firstname, lastname, mail, salted_password, hashed_password FROM users WHERE login=?');
		if ($statement->execute(array($username))) {
			$foundUserRecord = $statement->fetch();
		}
		
		$explodedName = explode(' ', $userData['name']);
		if (count($explodedName) > 1) {
			$firstName = implode(' ', array_slice($explodedName, 0, -1));
			$lastName = implode('', array_slice($explodedName, -1, 1));
		} else {
			$firstName = is_array($explodedName) ? $explodedName[0] : '';
			$lastName = 'no-lastname-given';
		}

		if ($foundUserRecord === FALSE) {
			$sql = "INSERT INTO users (login, firstname, lastname, mail, mail_notification, admin, status, language, created_on, updated_on, type, salted_password, hashed_password, img_hash, signed_cla)";
			$sql .= " VALUES (" . $dbh->quote($username) . ", " . $dbh->quote($firstName). ", " . $dbh->quote($lastName) . ", " . $dbh->quote($userData['email']) . ",  1, 0, 1, 'en', NOW(), NOW(), 'User', " . $dbh->quote($userData['salted_password']) . ", " . $dbh->quote($userData['hashed_password']) . ", " . $dbh->quote($userData['tx_t3ouserimage_img_hash']) . ", ".$dbh->quote($userData['tx_t3ocla_hassignedcla']).")";
			$result = $dbh->query($sql);
			$userId = $dbh->lastInsertId();
		} else {
			$recordIsCurrentEnough = (
				$foundUserRecord['firstname'] == $firstName &&
				$foundUserRecord['lastname'] == $lastName &&
				$foundUserRecord['mail'] == $userData['email'] &&
				$foundUserRecord['salted_password'] == $userData['salted_password'] &&
				$foundUserRecord['hashed_password'] == $userData['hashed_password'] &&
				(isset($foundUserRecord['img_hash']) && ($foundUserRecord['img_hash'] == $userData['tx_t3ouserimage_img_hash'])) &&
				$foundUserRecord['signed_cla'] == $userData['tx_t3ocla_hassignedcla']
			);
			if (!$recordIsCurrentEnough) {
				$sql = "UPDATE users SET firstname=" . $dbh->quote($firstName). ", lastname=" . $dbh->quote($lastName) . ", mail=" . $dbh->quote($userData['email']) . ", updated_on = NOW(), img_hash=" . $dbh->quote($userData['tx_t3ouserimage_img_hash']) . ", salted_password = " . $dbh->quote($userData['salted_password']) . ", hashed_password = " . $dbh->quote($userData['hashed_password']) . ", signed_cla = " . $dbh->quote($userData['tx_t3ocla_hassignedcla']) . " WHERE login = " . $dbh->quote($username);
				$result = $dbh->query($sql);
			}
			$userId = $foundUserRecord['id'];
		}

		$sql = "DELETE FROM tokens WHERE id = " . intval($userId);
		$dbh->query($sql);

		$autologinToken = sha1(time() + mt_rand(0, 10000000));
		$sql = "INSERT INTO tokens (user_id, action, value, created_on) VALUES (" . intval($userId) .", 'autologin', '$autologinToken', NOW())";
		$dbh->query($sql);
		
	} catch (Exception $exception) {
	    syslog(LOG_ERR, 'TYPO3 SIGSSO Error: ' . $exception->getMessage() . ' in file ' . $exception->getFile() . ' line ' . $exception->getLine());
		return;
	}

		// prepare sessiondata return-values
    	// Sessiondata is stored in this Format :
    	// Array(
    	//	[redirecturl] => $redirecturl
    	//	[0] => Array(
    	//		"CookieName" => $cookiename
    	//		"CookieValue" => $cookievalue
    	//		"CookieExpires" => $expires
    	//		)
    	//	[1] => Array(
    	//		"Cookiename" => $cookiename
    	//		... and so on
    	//		)
    	// [1] if you need to pass more than one cookie
    	//
    $returnData = array(
		'redirecturl' => $sso_url . validateReturnToUrl($_GET['returnTo']),
		'0' => array(
			'CookieName' => 'autologin',
			'CookieValue' => $autologinToken,
			'CookieExpires' => 0,
		)
	);
   	return $returnData;	
}


function validateReturnToUrl($returnToUrl) {
	// decoding is needed because of the redirect from /sso/sigsso.php to /scripts/sigsso.php 
	// which somehow causes a double url encoding of the returnTo parameter
	$returnToUrl = rawurldecode($returnToUrl);
        if (!is_string($returnToUrl)) {
                return '';
        } else if (preg_match('#[[:cntrl:]])#', $returnToUrl)) {
                return '';
        }
        return $returnToUrl;
}


?>
